# Package com.google.firebase.dataconnect.generated

This Kotlin package provides a type-safe library
for the Firebase Data Connect connector named `example`,
with service ID `fitlog`
hosted in `asia-northeast3`.

To use this package, it is typical to add the following imports
to each Kotlin source file that uses the connector:

```kotlin
import com.google.firebase.*
import com.google.firebase.dataconnect.*
import com.google.firebase.dataconnect.generated.*
```

All code samples below assume that these imports are present
in the containing file.

This code was generated by the Firebase Data Connect code generator.
Any changes made to the code, including this file, will be overwritten
the next time that code generation is performed.
See <https://firebase.google.com/docs/data-connect/android-sdk>
for more details.
Report issues to the Firebase Android SDK GitHub repository:
<https://github.com/firebase/firebase-android-sdk>.

## Data Connect SDK Setup

Before using the Data Connect SDK, you must first set up your application
to use the Firebase Android SDK in general as documented at
<https://firebase.google.com/docs/android/setup>.
This includes steps such as creating a Firebase project,
adding Firebase to your Android Studio project,
and initializing Firebase in your Kotlin code.

Then, follow the steps at
<https://firebase.google.com/docs/data-connect/android-sdk>
to set up your application specifically for using the Data Connect SDK.
This includes steps such as
adding the `com.google.firebase:firebase-dataconnect` Gradle dependency,
adding the Kotlin Serialization Gradle plugin and dependency,
and adding the Kotlin Coroutines dependency.

## ExampleConnector - The Main Class

The [ExampleConnector] class is the main entry point
for accessing the `example` Data Connect connector.
First, it provides methods, extension functions, and properties for retrieving
instances of itself.
Second, it provides one property for each query and each mutation
defined in the GraphQL source files.
Finally, it provides a [ExampleConnector.dataConnect] property
that provides access to the underlying
[com.google.firebase.dataconnect.FirebaseDataConnect] instance.

### ExampleConnector - Retrieving Instances

The default instance of [ExampleConnector] can be retrieved,
creating it if it does not already exist, by accessing the [instance] extension
property of the companion object of [ExampleConnector].
For example,

```kotlin
val connector: ExampleConnector = ExampleConnector.instance
```

If the default [ExampleConnector] instance is not sufficient,
an instance with different settings can be created (or retrieved) using the
[getInstance] extension function of the companion object of
[ExampleConnector].
For example,

```kotlin
val connector: ExampleConnector = ExampleConnector.getInstance(
  Firebase.app("custom-app-name")
)
```

### ExampleConnector - Query and Mutation Properties

The `example` Data Connect connector defines
5 queries and
4 mutations,
a total of 9 operations.
Each of these operations is exposed
as a property of [ExampleConnector].


An example of the property for a query
is the query named "GetMovieById",
which can be accessed via the [ExampleConnector.getMovieById] property.


An example of the property for a mutation
is the mutation named "AddReview",
which can be accessed via the [ExampleConnector.addReview] property.


### ExampleConnector - The `dataConnect` Property

The [ExampleConnector.dataConnect] property
provides access to the underlying
[com.google.firebase.dataconnect.FirebaseDataConnect] instance.
Although basic applications will likely not need to access this property,
it is provided for advanced use cases,
such as connecting to the Data Connect emulator
(instead of the Data Connect production servers)
and "closing" the
[com.google.firebase.dataconnect.FirebaseDataConnect] instance

For example, to connect to the Data Connect emulator,
use the following code:

```kotlin
val connector = ExampleConnector.instance
connector.dataConnect.useEmulator()
```

If your application only needs access to the Data Connect service for a short
time, you can close the underlying
[com.google.firebase.dataconnect.FirebaseDataConnect] instance
to release its resources. A new instance can be retrieved later by
accessing the [instance] extension property of the companion object of
[ExampleConnector].

```kotlin
// Before close(), the `instance` property returns the same object each time.
val connector1 = ExampleConnector.instance
val connector2 = ExampleConnector.instance
check(connector1 === connector2)

connector1.dataConnect.close()

// After close(), the `instance` property returns a new instance.
val connector3 = ExampleConnector.instance
check(connector1 !== connector3)
```

### Data Connect Debug Logging

To enable debug logging for the Data Connect SDK,
set the [com.google.firebase.dataconnect.logLevel]
extension property of the companion object of
[com.google.firebase.dataconnect.FirebaseDataConnect] to
[com.google.firebase.dataconnect.FirebaseDataConnect.LogLevel.DEBUG]:

```Kotlin
FirebaseDataConnect.logLevel.value = LogLevel.DEBUG
```

With debug logging enabled,
the SDK will log verbose information to Android's "logcat" logger.
This extra information can be very helpful when troubleshooting
issues with the SDK and/or reporting issues to Google.

## Executing Queries

Executing a query is as simple as calling the `execute()` method
of the corresponding property of [ExampleConnector].
Most queries require "variables",
arguments to the query that affect its result.
Query variables are either "optional" or "required",
based on the "non-nullable" marker indicated in the GraphQL source file.
_Required_ variables are specified as arguments to the `execute()` method.
_Optional_ variables are specified in a Kotlin DSL block as the
last argument of the `execute()` method.


### Executing Queries with No Variables

If a query has no variables then it can be easily executed
by calling the `execute()` method with no arguments.

For example, the "ListMovies" query has no variables
and can be executed via the
[ExampleConnector.listMovies]
property as follows:

```kotlin
val connector = ExampleConnector.instance
val queryResult = connector.listMovies.execute()
println("ListMovies query returned: ${queryResult.data}")
```


### Executing Queries with Required Variables

If a query has _required_ variables then they must be specified as
arguments to the `execute()` method.

For example, the "GetMovieById" query has 1 required variable ("id")
and can be executed via the [ExampleConnector.getMovieById]
property as follows:

```kotlin
val connector = ExampleConnector.instance
val queryResult = connector.getMovieById.execute(id=java.util.UUID.randomUUID())
println("GetMovieById query returned: ${queryResult.data}")
```


### Executing Queries with Optional Variables

If a query has _optional_ variables then, by definition,
they are _not_ required to be specified to the `execute()` method;
however, if they _are_ specified,
then they are specified in a Kotlin DSL block as the last argument
of the `execute()` method.

For example, the "SearchMovie" query has 2 optional variables ("titleInput" and "genre")
and can be executed via the [ExampleConnector.searchMovie]
property as follows:

```kotlin
val connector = ExampleConnector.instance
val queryResult = connector.searchMovie.execute {
  titleInput = "waldo"
  genre = "baz"
}
println("SearchMovie query returned: ${queryResult.data}")
```


## Executing Mutations

Executing a mutation is as simple as calling the `execute()` method
of the corresponding property of [ExampleConnector].
Most mutations require "variables",
arguments to the mutation that affect its result.
Mutation variables are either "optional" or "required",
based on the "non-nullable" marker indicated in the GraphQL source file.
_Required_ variables are specified as arguments to the `execute()` method.
_Optional_ variables are specified in a Kotlin DSL block as the
last argument of the `execute()` method.



### Executing Mutations with Required Variables

If a mutation has _required_ variables then they must be specified as
arguments to the `execute()` method.

For example, the "AddReview" mutation has 3 required variables ("movieId", "rating", and "reviewText")
and can be executed via the [ExampleConnector.addReview]
property as follows:

```kotlin
val connector = ExampleConnector.instance
val mutationResult = connector.addReview.execute(movieId=java.util.UUID.randomUUID(), rating=7324, reviewText="waldo")
println("AddReview mutation returned: ${mutationResult.data}")
```




## Epilogue

// The lines below are used by the code generator to ensure that this file is deleted if it is no
// longer needed. Any files in this directory that contain the lines below will be deleted by the
// code generator if the file is no longer needed. If, for some reason, you do _not_ want the code
// generator to delete this file, then remove the line below (and this comment too, if you want).

// FIREBASE_DATA_CONNECT_GENERATED_FILE MARKER 42da5e14-69b3-401b-a9f1-e407bee89a78
// FIREBASE_DATA_CONNECT_GENERATED_FILE CONNECTOR example
